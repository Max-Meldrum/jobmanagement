syntax = "proto3";

// Brought in from scalapb-runtime
import "scalapb/scalapb.proto";
import "google/protobuf/wrappers.proto";


option (scalapb.options) = {
  package_name: "runtime.protobuf.messages"

  // All classes that extend a sealed trait need to be in the same Scala
  // file, so we set single_file to true.
  single_file: true
  flat_package: true
  preamble: "sealed trait AllocateResponse"
  preamble: "sealed trait SlotRequestResp"
};

// Traits

// SlotState

enum SlotState {
    FREE = 0;
    ALLOCATED = 1;
}

// SlotRequestResp

message NoSlotsAvailable {
    option (scalapb.message).extends = "SlotRequestResp";
}

message NoTaskManagerAvailable {
    option (scalapb.message).extends = "SlotRequestResp";
}

message Unexpected {
    option (scalapb.message).extends = "SlotRequestResp";
}

//case class SlotAvailable(taskSlot: Seq[TaskSlot], addr: Address) extends SlotRequestResp
message SlotAvailable {
    option (scalapb.message).extends = "SlotRequestResp";
    repeated TaskSlot taskSlot = 1;
    AddressProto addr = 2 [(scalapb.field).no_box = true];
}


// Represents a Remote ActorRef
message ActorRefProto {
    string path = 1;
}

// Represents an Akka Address
message AddressProto {
    string system = 1;
    string hostname = 2;
    uint32 port = 3;
    string protocol = 4 [(scalapb.field).no_box = false];
}

// Represents an InetSocketAddress
message InetProto {
    string ip = 1;
    int32 port = 2;
}

//case object TaskManagerInit
// well in scalapb, case class..
message TaskManagerInit { }


//case class ArcTask(name: String, expr: String, vec: String,
//result: Option[String] = None, id: Option[Int], status: Option[String)
message ArcTask {
    string name = 1;
    int32 cores = 2;
    int32 memory = 3;
    string expr = 4;
    string vec = 5;
    google.protobuf.StringValue result = 6; // To make it an Option
    google.protobuf.Int32Value id = 7; // Added when received
    google.protobuf.StringValue status = 8; // To make it an Option
}

message ArcTaskUpdate {
    ArcTask task = 1 [(scalapb.field).no_box = true];
}

//case class ArcProfile(cpuCores: Double, memoryInMB: Long) {
//def matches(other: ArcProfile): Boolean =
//this.cpuCores >= other.cpuCores && this.memoryInMB >= other.memoryInMB
//}
message ArcProfile {
    option (scalapb.message).extends = "runtime.protobuf.messages.ProfileMatcher";
    double cpuCores = 1;
    int64 memoryInMb = 2; // Long
}

//case class ArcJob(id: String, profile: ArcProfile, tasks: Seq[ArcTask], masterRef: Option[AppMasterRef] = None)
message ArcJob {
    string id = 1;
    ArcProfile profile = 2 [(scalapb.field).no_box = true]; // Not Option[]
    repeated ArcTask tasks = 3;
    ActorRefProto appMasterRef = 4;
    google.protobuf.StringValue status = 5; // To make it an Option
}

// TaskMaster related

//case class TaskMasterHeartBeat
message TaskMasterHeartBeat {}

//case class TaskMasterStatus(status: String)
message TaskMasterStatus {
    // FAILED, KILLED, SUCCEEDED
    string status = 1;
}

//case class TaskTransferConn(inet: InetSocketAddress)
message TaskTransferConn {
    InetProto inet = 1 [(scalapb.field).no_box = true];
}

//case class TaskTransferAck(inet: InetSocketAddress) extends Event
message TaskTransferAck {
    option (scalapb.message).extends = "akka.io.Tcp.Event";
    InetProto inet = 1 [(scalapb.field).no_box = true];
}

//case object TaskTransferError
message TaskTransferError {}

//case class TaskTransferComplete(inet: InetSocketAddress)
message TaskTransferComplete{
    InetProto inet = 1 [(scalapb.field).no_box = true];
}

//case object TasksCompiled
message TasksCompiled {}


// TaskManager related

//case class AllocateSuccess(job: ArcJob, ref: ActorRef) extends AllocateResponse
message AllocateSuccess {
    option (scalapb.message).extends = "AllocateResponse";
    ArcJob job = 1 [(scalapb.field).no_box = true]; // Not Option[]
    ActorRefProto ref = 2 [(scalapb.field).no_box = true]; // Not Option[]
}

//case class AllocateFailure(resp: SlotRequestResp) extends AllocateResponse
message AllocateFailure{
    option (scalapb.message).extends = "AllocateResponse";
    oneof resp {
        NoSlotsAvailable no_slots = 2;
        NoTaskManagerAvailable no_manager = 3;
        Unexpected unexpected= 4;
    }
}

//case class AllocateError(err:  String) extends AllocateResponse
message AllocateError {
    option (scalapb.message).extends = "AllocateResponse";
    string err = 1;
}

//case class TaskSlot(index: Int, profile: ArcProfile, state: SlotState = Free)
message TaskSlot {
    int32 index = 1;
    ArcProfile profile = 2 [(scalapb.field).no_box = true]; // Not Option[]
    SlotState state = 3 [(scalapb.field).no_box = true]; // Not Option[]
}

//case class Allocate(job: ArcJob, slots: Seq[TaskSlot])
message Allocate {
    ArcJob job = 1 [(scalapb.field).no_box = true]; // Not Option[]
    repeated TaskSlot slots = 2;
}

//case class ReleaseSlots(slotIndxes: Seq[Int])
message ReleaseSlots {
    repeated int32 slotIndexes = 1;
}

//case class SlotUpdate(slots: Seq[TaskSlot])
message SlotUpdate {
    repeated TaskSlot slots = 1;
}


// StateManager related

//case class StateManagerJob(appMasterRef: ActorRef, job: ArcJob)
message StateManagerJob {
    ActorRefProto ref = 1 [(scalapb.field).no_box = true];
    ArcJob job = 2 [(scalapb.field).no_box = true];
}

//case class StateMasterConn(stateMaster: ActorRef)
message StateMasterConn {
    ActorRefProto ref = 1 [(scalapb.field).no_box = true];
}

//case class ExecutorTaskExit(task: ArcTask)
message ExecutorTaskExit {
    ArcTask task = 1 [(scalapb.field).no_box = true];
}


// Yarn

message YarnTaskMasterUp {
    ActorRefProto ref = 1 [(scalapb.field).no_box = true];
}

message YarnTaskTransferred {
    string binPath = 1;
    ArcTask task = 2 [(scalapb.field).no_box = true];
}


// For now as we are sending arguments to the binary
message YarnExecutorUp {
    int32 taskId = 1;
}

message YarnExecutorStart {
    ArcTask task = 1 [(scalapb.field).no_box = true];
}

