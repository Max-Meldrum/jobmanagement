syntax = "proto3";

// Brought in from scalapb-runtime
import "scalapb/scalapb.proto";
import "google/protobuf/wrappers.proto";


option (scalapb.options) = {
  package_name: "runtime.common"
  import: "runtime.common.TypeMappers._"

  // All classes that extend a sealed trait need to be in the same Scala
  // file, so we set single_file to true.
  single_file: true
  preamble: "sealed trait AllocateResponse"
  preamble: "sealed trait SlotRequestResp"
};

// Traits

// SlotState

enum SlotState {
    FREE = 0;
    ALLOCATED = 1;
}

// SlotRequestResp

message NoSlotsAvailable {
    option (scalapb.message).extends = "SlotRequestResp";
}

message NoTaskManagerAvailable {
    option (scalapb.message).extends = "SlotRequestResp";
}

message Unexpected {
    option (scalapb.message).extends = "SlotRequestResp";
}

//case class SlotAvailable(taskSlot: Seq[TaskSlot], addr: Address) extends SlotRequestResp
message SlotAvailable {
    option (scalapb.message).extends = "SlotRequestResp";
    repeated TaskSlot taskSlot = 1;
    AddressProto addr = 2 [(scalapb.field).no_box = true];
}


// Represents a Remote ActorRef
message ActorRefProto {
    string path = 1;
}

// Represents an Akka Address
message AddressProto {
    string system = 1;
    string hostname = 2;
    uint32 port = 3;
    string protocol = 4 [(scalapb.field).no_box = false];
}

// Represents an InetSocketAddress
message InetProto {
    string ip = 1;
    int32 port = 2;
}

//case object TaskManagerInit
// well in scalapb, case class..
message TaskManagerInit { }


//case class WeldTask(expr: String, vec: String, result: Option[String] = None)
message WeldTask {
    string expr = 1;
    string vec = 2;
    google.protobuf.StringValue result = 3; // To make it an Option
}

//case class WeldJob(tasks: Seq[WeldTask])
message WeldJob {
    repeated WeldTask tasks = 1;
}

//case class WeldTaskCompleted(task: WeldTask)
message WeldTaskCompleted {
    WeldTask task = 1 [(scalapb.field).no_box = true];
}

//case class ArcProfile(cpuCores: Double, memoryInMB: Long) {
//def matches(other: ArcProfile): Boolean =
//this.cpuCores >= other.cpuCores && this.memoryInMB >= other.memoryInMB
//}
message ArcProfile {
    option (scalapb.message).extends = "runtime.common.ProfileMatcher";
    double cpuCores = 1;
    int64 memoryInMb = 2; // Long
}

//case class ArcJob(id: String, profile: ArcProfile, job: WeldJob, masterRef: Option[AppMasterRef] = None)
message ArcJob {
    string id = 1;
    ArcProfile profile = 2 [(scalapb.field).no_box = true]; // Not Option[]
    WeldJob job = 3 [(scalapb.field).no_box = true]; // Not Option[]
    ActorRefProto ref = 4;
}

// TaskMaster related

//case class TaskMasterHeartBeat
message TaskMasterHeartBeat {}

//case class TaskMasterFailure
message TaskMasterFailure {}

//case class TaskTransferConn(inet: InetSocketAddress)
message TaskTransferConn {
    InetProto inet = 1 [(scalapb.field).no_box = true];
}

//case class TaskTransferAck(inet: InetSocketAddress) extends Event
message TaskTransferAck {
    option (scalapb.message).extends = "akka.io.Tcp.Event";
    InetProto inet = 1 [(scalapb.field).no_box = true];
}

//case object TaskTransferError
message TaskTransferError {}

//case class TaskTransferComplete(inet: InetSocketAddress)
message TaskTransferComplete{
    InetProto inet = 1 [(scalapb.field).no_box = true];
}

//case object TasksCompiled
message TasksCompiled {}


// TaskManager related

//case class AllocateSuccess(job: ArcJob, ref: ActorRef) extends AllocateResponse
message AllocateSuccess {
    option (scalapb.message).extends = "AllocateResponse";
    ArcJob job = 1 [(scalapb.field).no_box = true]; // Not Option[]
    ActorRefProto ref = 2 [(scalapb.field).no_box = true]; // Not Option[]
}

//case class AllocateFailure(resp: SlotRequestResp) extends AllocateResponse
message AllocateFailure{
    option (scalapb.message).extends = "AllocateResponse";
    oneof resp {
        NoSlotsAvailable no_slots = 2;
        NoTaskManagerAvailable no_manager = 3;
        Unexpected unexpected= 4;
    }
}

//case class AllocateError(err:  String) extends AllocateResponse
message AllocateError {
    option (scalapb.message).extends = "AllocateResponse";
    string err = 1;
}

//case class TaskSlot(index: Int, profile: ArcProfile, state: SlotState = Free) {
//def newState(s: SlotState): TaskSlot = {
//this.copy(state = s)
//}
//}
message TaskSlot {
    int32 index = 1;
    ArcProfile profile = 2 [(scalapb.field).no_box = true]; // Not Option[]
    SlotState state = 3 [(scalapb.field).no_box = true]; // Not Option[]
}

//case class Allocate(job: ArcJob, slots: Seq[TaskSlot])
message Allocate {
    ArcJob job = 1 [(scalapb.field).no_box = true]; // Not Option[]
    repeated TaskSlot slots = 2;
}

//case class ReleaseSlots(slotIndxes: Seq[Int])
message ReleaseSlots {
    repeated int32 slotIndexes = 1;
}

//case class SlotUpdate(slots: Seq[TaskSlot])
message SlotUpdate {
    repeated TaskSlot slots = 1;
}


// StateManager related

//case class StateManagerJob(appMasterRef: ActorRef)
message StateManagerJob {
    ActorRefProto ref = 1 [(scalapb.field).no_box = true];
}

//case class StateMasterConn(stateMaster: ActorRef)
message StateMasterConn {
    ActorRefProto ref = 1 [(scalapb.field).no_box = true];
}

